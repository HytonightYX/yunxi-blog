<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yunxi.site","root":"/blog/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="… 第一章 绪论略 第二章 算法效率分析">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础知识点整理">
<meta property="og:url" content="http://yunxi.site/blog/2019/06/18/算法求生—面向考点复习/index.html">
<meta property="og:site_name" content="Hytonight云息">
<meta property="og:description" content="… 第一章 绪论略 第二章 算法效率分析">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1434960/201901/1434960-20190122132330779-460512302.png">
<meta property="og:image" content="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D">
<meta property="og:image" content="https://math.jianshu.com/math?formula=T(n">
<meta property="og:image" content="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D">
<meta property="og:image" content="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D">
<meta property="og:image" content="https://math.jianshu.com/math?formula=af(n%2Fb">
<meta property="og:image" content="https://math.jianshu.com/math?formula=c%3C1">
<meta property="og:image" content="https://math.jianshu.com/math?formula=T(n">
<meta property="og:image" content="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D">
<meta property="og:image" content="https://math.jianshu.com/math?formula=T(n">
<meta property="og:image" content="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D%5Clog%20n">
<meta property="og:image" content="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/252e9291944f6d8b2d444da3ed7efc1f9d0fc2c3">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/11d74cc0fe9d309dabaea86254c9fe8528b39ed3">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/89950a9ac122ea7e0bf1c669ae1313a749661063">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2853119-7dc08762a91519ed.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2853119-5105f2ee46526806.png">
<meta property="og:updated_time" content="2020-02-13T03:18:00.898Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法基础知识点整理">
<meta name="twitter:description" content="… 第一章 绪论略 第二章 算法效率分析">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/1434960/201901/1434960-20190122132330779-460512302.png">

<link rel="canonical" href="http://yunxi.site/blog/2019/06/18/算法求生—面向考点复习/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>算法基础知识点整理 | Hytonight云息</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?57d30e6a21aa4345d6c1d19d35e02e03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hytonight云息</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="default">
    <link itemprop="mainEntityOfPage" href="http://yunxi.site/blog/2019/06/18/算法求生—面向考点复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Hytonight云息">
      <meta itemprop="description" content="云之息，浴乎沂，风乎舞雩，咏而归">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hytonight云息">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法基础知识点整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-18 17:21:40" itemprop="dateCreated datePublished" datetime="2019-06-18T17:21:40+08:00">2019-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-13 11:18:00" itemprop="dateModified" datetime="2020-02-13T11:18:00+08:00">2020-02-13</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/blog/2019/06/18/算法求生—面向考点复习/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/2019/06/18/算法求生—面向考点复习/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>…</p>
<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><p>略</p>
<h2 id="第二章-算法效率分析"><a href="#第二章-算法效率分析" class="headerlink" title="第二章 算法效率分析"></a>第二章 算法效率分析</h2><a id="more"></a>
<h3 id="渐进符号—时间复杂度-空间复杂度"><a href="#渐进符号—时间复杂度-空间复杂度" class="headerlink" title="渐进符号—时间复杂度/空间复杂度"></a>渐进符号—时间复杂度/空间复杂度</h3><p><a href="https://www.jianshu.com/p/fd1335c59c6f" target="_blank" rel="noopener">https://www.jianshu.com/p/fd1335c59c6f</a></p>
<p><a href="https://www.cnblogs.com/sequix/p/8558534.html" target="_blank" rel="noopener">https://www.cnblogs.com/sequix/p/8558534.html</a></p>
<p>$O$ 给出了算法运行时间的上界 ， 也就是最坏情况下的时间复杂度</p>
<p>$o$ 严格上界</p>
<p>$ \Omega$ 给出了算法运行时间的下界 ， 也就是最好情况下的时间复杂度</p>
<p>$\omega$ 严格下界</p>
<p>$\Theta$ 给出了算法运行时间的上界和下界 ， 这里 θ ( f(n) ) 是渐进的确界</p>
<h3 id="求递归的时间-空间复杂度"><a href="#求递归的时间-空间复杂度" class="headerlink" title="求递归的时间/空间复杂度"></a>求递归的时间/空间复杂度</h3><p><a href="https://lanzm.github.io/2017/09/21/20170921Algorithm-ThreeMethods/" target="_blank" rel="noopener">https://lanzm.github.io/2017/09/21/20170921Algorithm-ThreeMethods/</a></p>
<h4 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h4><p>a.猜测解的形式</p>
<p>b.用数学归纳法找出使解真正成立的常数</p>
<h4 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h4><p>例题：求解递推方程$T(n) = T(n/3) + T(2n/3) + n$</p>
<p><img src="https://img2018.cnblogs.com/blog/1434960/201901/1434960-20190122132330779-460512302.png" alt="1434960-20190122132330779-460512302"></p>
<p>设树的层数为k，则$n * (2 / 3)k = 1$，解得$k = log(3/2n)$。另一方面，每层结点的数值之和都是$O(n)$，因此$T(n) = O(nlog3/2n) = O(nlogn)$</p>
<h4 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h4><p><a href="https://www.cnblogs.com/sequix/p/8558534.html" target="_blank" rel="noopener">https://www.cnblogs.com/sequix/p/8558534.html</a></p>
<p>只适用于特定的递归式</p>
<p> $T(n) = aT(\frac{n}{b})+f(n),其中a \geq 1, b &gt; 1, f(n)是一个渐进趋正的函数$</p>
<ul>
<li>如果$f(n)$多项式小于<img src="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D" alt="n^{\log_ba}">，则<img src="https://math.jianshu.com/math?formula=T(n" alt="T(n)">)的上限就是<img src="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D" alt="n^{\log_ba}"></li>
<li>如果$f(n)$多项式大于<img src="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D" alt="n^{\log_ba}">，且 <img src="https://math.jianshu.com/math?formula=af(n%2Fb" alt="af(n/b)\leq cf(n)">%5Cleq%20cf(n))，其中<img src="https://math.jianshu.com/math?formula=c%3C1" alt="c&lt;1">，则<img src="https://math.jianshu.com/math?formula=T(n" alt="T(n)">)的上限就是的上限就是$f(n)$</li>
<li>如果$f(n)$跟<img src="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D" alt="n^{\log_ba}">有相同的增长阶，则<img src="https://math.jianshu.com/math?formula=T(n" alt="T(n)">)的上限就是<img src="https://math.jianshu.com/math?formula=n%5E%7B%5Clog_ba%7D%5Clog%20n" alt="n^{\log_ba}\log n"></li>
</ul>
<h2 id="第三章-蛮力法"><a href="#第三章-蛮力法" class="headerlink" title="第三章 蛮力法"></a>第三章 蛮力法</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DFS(G)</span><br><span class="line"></span><br><span class="line">count ← 0</span><br><span class="line">for each vertex v in V do</span><br><span class="line">	if v is marked with 0</span><br><span class="line">		dfs(v)</span><br><span class="line"></span><br><span class="line">dfs(v)</span><br><span class="line">   count ← count + 1</span><br><span class="line">   mark v with 0</span><br><span class="line">   for each vertex w in V adjacent to v do</span><br><span class="line">     if w is marked with 0</span><br><span class="line">       dfs(w)</span><br></pre></td></tr></table></figure>
<p>邻接表 O(|V|+|E|)</p>
<p>邻接矩阵 O(|V|^2)</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BFS(G)</span><br><span class="line"></span><br><span class="line">count ← <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> each vertex v in V <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">    bfs(v);</span><br><span class="line">    </span><br><span class="line">count ← count + <span class="number">1</span>;</span><br><span class="line">mark v with count <span class="keyword">and</span> initialize a <span class="built_in">queue</span> with v;</span><br><span class="line"><span class="keyword">while</span> the <span class="built_in">queue</span> is <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> each vertex w in V adjacent to the front vertex <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">      count ← count + <span class="number">1</span>;</span><br><span class="line">			mark w with count</span><br><span class="line">			add w to the <span class="built_in">queue</span>;</span><br><span class="line">	remove the front vertex from the <span class="built_in">queue</span></span><br></pre></td></tr></table></figure>
<p>邻接表 O(|V|+|E|)</p>
<p>邻接矩阵 O(|V|^2)</p>
<h2 id="第四章-减治法"><a href="#第四章-减治法" class="headerlink" title="第四章 减治法"></a>第四章 减治法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><a href="https://zhuanlan.zhihu.com/p/35328552" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35328552</a></p>
<p><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif" alt="v2-91b76e8e4dab9b0cad9a017d7dd431e2_b"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr || len) <span class="keyword">return</span>;</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 从第二个元素开始往前比较</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 图示里看上去是要交换，但是其实让后一个元素直接等于前一个即可</span></span><br><span class="line">            <span class="comment">// 也就是让后一个被前一个“覆盖”掉</span></span><br><span class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; temp &lt; <span class="built_in">array</span>[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[index] = arr[index - <span class="number">1</span>];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// index这个位置自然而然就会空出来</span></span><br><span class="line">            arr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><a href="https://www.jianshu.com/p/b59db381561a" target="_blank" rel="noopener">https://www.jianshu.com/p/b59db381561a</a></p>
<ul>
<li>一个有向无环图可以有一个或多个拓扑排序序列</li>
<li>O(N+E)</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;       <span class="comment">// 未搜索到数据返回-1下标</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;            <span class="comment">// 最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">			ret = mid;  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;     <span class="comment">// 单一出口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt; end)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;    <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line">	<span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">		<span class="keyword">return</span> binary_search(arr, start, mid - <span class="number">1</span>, khey);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">		<span class="keyword">return</span> binary_search(arr, mid + <span class="number">1</span>, end, khey);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">return</span> mid;        <span class="comment">//最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伪代码书本P116</p>
<h4 id="找大于L小于R的所有数字的范围"><a href="#找大于L小于R的所有数字的范围" class="headerlink" title="找大于L小于R的所有数字的范围"></a>找大于L小于R的所有数字的范围</h4><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>解答在<strong>Solution</strong>里</p>
<p>注意是范围哦，不用把其中的数字打印出来。</p>
<p>只需要两次二分找到L和R，然后一次性输出即可。这样是严格意义上的O(logN)算法</p>
<h2 id="第五章-分治法"><a href="#第五章-分治法" class="headerlink" title="第五章 分治法"></a>第五章 分治法</h2><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><p><a href="https://www.geeksforgeeks.org/merge-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/merge-sort/</a></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><a href="https://mp.weixin.qq.com/s/PQLC7qFjb74kt6PdExP8mw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PQLC7qFjb74kt6PdExP8mw</a></p>
<h4 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序——挖坑法</span></span><br><span class="line"><span class="comment"> * 代码改自</span></span><br><span class="line"><span class="comment"> *    https://mp.weixin.qq.com/s/PQLC7qFjb74kt6PdExP8mw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选取第一个元素为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    <span class="comment">// 坑的位置，初始化为pivot的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大循环在左右指针重合或者交错时结束</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="comment">// right指针从右向左比较</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">	          <span class="keyword">if</span> (arr[right] &lt; pivot) &#123;</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                index = right;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left指针从左向右比较</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &gt; pivot) &#123;</span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">                index = left;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[index] = pivot;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到基准位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针交换法-书上方法"><a href="#指针交换法-书上方法" class="headerlink" title="指针交换法 (书上方法)"></a>指针交换法 (书上方法)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序——指针交换法(仅partition部分)</span></span><br><span class="line"><span class="comment"> * 代码改自</span></span><br><span class="line"><span class="comment"> *    https://mp.weixin.qq.com/s/PQLC7qFjb74kt6PdExP8mw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选取第一个元素为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">// 控制right指针比较并左移</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) </span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">// 控制left指针右移</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; pivot)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="comment">// 交换left和right指向的元素</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="keyword">int</span> p = arr[left];</span><br><span class="line">          arr[left] = arr[right];</span><br><span class="line">          arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换pivot和left最终位置</span></span><br><span class="line">    <span class="keyword">int</span> p = arr[left];</span><br><span class="line">    arr[left] = arr[startIndex];</span><br><span class="line">    arr[startIndex] = p;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少</p>
</blockquote>
<h2 id="第六章-变治法"><a href="#第六章-变治法" class="headerlink" title="第六章 变治法"></a>第六章 变治法</h2><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><h3 id="二三树"><a href="#二三树" class="headerlink" title="二三树"></a>二三树</h3><p><a href="https://mp.weixin.qq.com/s/qqugzuLxJ8ja7oyMgn7bEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qqugzuLxJ8ja7oyMgn7bEQ</a></p>
<p>查找、<strong>插入（4种情况）</strong>——关键：中键上移</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><a href="https://mp.weixin.qq.com/s/Och3KXhbm1mq-ce4Yp0hRg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Och3KXhbm1mq-ce4Yp0hRg</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立父節點指標和子節點指標</span></span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子節點指標在範圍內才做比較</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>出队、入队复杂度为$Ologn$</p>
<h2 id="第七章-时空权衡"><a href="#第七章-时空权衡" class="headerlink" title="第七章 时空权衡"></a>第七章 时空权衡</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><a href="https://mp.weixin.qq.com/s/WGqndkwLlzyVOHOdGK7X4Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WGqndkwLlzyVOHOdGK7X4Q</a></p>
<ul>
<li>不需要通过比较（ O(logN) ），而是通过元素下标来确定元素位置</li>
<li>取值范围不能很大——空间复杂度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> sorted[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 1 得到数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len, i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max) &#123;</span><br><span class="line">         	 max = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 根据数组最大值确定统计数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> *countArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (max + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 遍历数组，填充统计数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        countArray[<span class="built_in">array</span>[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4 遍历统计数组，输出结果</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">            sorted[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(countArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第八章-动态规划"><a href="#第八章-动态规划" class="headerlink" title="第八章 动态规划"></a>第八章 动态规划</h2><h3 id="动态规划性质-amp-amp-适用范围？"><a href="#动态规划性质-amp-amp-适用范围？" class="headerlink" title="动态规划性质&amp;&amp;适用范围？"></a>动态规划性质&amp;&amp;适用范围？</h3><p>满足以下三个性质，就适合采用DP来解决：</p>
<ul>
<li><p><strong>（必需）最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
</li>
<li><p><strong>（必需）无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
</li>
<li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。<em>（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</em></p>
</li>
</ul>
<h3 id="动态规划典型例题"><a href="#动态规划典型例题" class="headerlink" title="动态规划典型例题"></a>动态规划典型例题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p><a href="https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html" target="_blank" rel="noopener">https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html</a></p>
<ul>
<li>如何根据表格反推最优解</li>
</ul>
<h4 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h4><p><a href="https://juejin.im/post/5b0c2583f265da08f50b4b33" target="_blank" rel="noopener">https://juejin.im/post/5b0c2583f265da08f50b4b33</a></p>
<ul>
<li>如何根据表格反推最优解？</li>
<li>反推的时候，如果不是来自左上，则是来自左或者上，这个时候要比较一下左和上哪个大，选择大的那个(文中的T(2,1)是来自T(1,1)的，而不是来自T(2, 0)的)</li>
</ul>
<h4 id="Floyd求完全最短路径"><a href="#Floyd求完全最短路径" class="headerlink" title="Floyd求完全最短路径"></a>Floyd求完全最短路径</h4><p><a href="https://mp.weixin.qq.com/s/7ul8ep08Us0HbSmy8QFHew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7ul8ep08Us0HbSmy8QFHew</a></p>
<p><strong>手算方式</strong>：P240</p>
<p>时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$</p>
<ul>
<li><p>若最短路径经过点k，则<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/252e9291944f6d8b2d444da3ed7efc1f9d0fc2c3" alt="2">；</p>
</li>
<li><p>若最短路径不经过点k，则<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/11d74cc0fe9d309dabaea86254c9fe8528b39ed3" alt="1">;</p>
</li>
</ul>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89950a9ac122ea7e0bf1c669ae1313a749661063" alt="3"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> let dist be a |V| × |V| <span class="built_in">array</span> of minimum distances initialized to ∞ (infinity)</span><br><span class="line"> <span class="keyword">for</span> each vertex v</span><br><span class="line">    dist[v][v] ← <span class="number">0</span></span><br><span class="line"> <span class="function"><span class="keyword">for</span> each <span class="title">edge</span> <span class="params">(u,v)</span></span></span><br><span class="line">    dist[u][v] ← w(u,v)  // the weight of the edge (u,v)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> k ← <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> i ← <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j ← <span class="number">1</span> to n <span class="keyword">do</span> </span><br><span class="line">      D[i, j] ← min&#123;D[i, j], D[i, k] + D[k, j]&#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)  </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">  	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)  </span><br><span class="line">    	<span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])  </span><br><span class="line">        e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>
<h3 id="和分治法的异同？"><a href="#和分治法的异同？" class="headerlink" title="和分治法的异同？"></a>和分治法的异同？</h3><table>
<thead>
<tr>
<th></th>
<th>分治法</th>
<th>动态规划</th>
</tr>
</thead>
<tbody>
<tr>
<td>同</td>
<td>都要求原问题具有最优子结构性质，都是通过组合子问题的解来解决整个问题</td>
<td>/</td>
</tr>
<tr>
<td>异</td>
<td>将问题划分成一些<strong>独立的</strong>子问题，递归地求解各个子问题，然后合并子问题的解而得到原问题的解</td>
<td>子问题<strong>不是独立</strong>的，也就是说动态规划分解出的各个子问题包含了公共的子问题</td>
</tr>
</tbody>
</table>
<h2 id="第九章-贪婪技术"><a href="#第九章-贪婪技术" class="headerlink" title="第九章 贪婪技术"></a>第九章 贪婪技术</h2><h3 id="三个条件"><a href="#三个条件" class="headerlink" title="三个条件"></a>三个条件</h3><ul>
<li>可行性：必须满足问题的约束</li>
<li>局部最优：当前已经有的部分解情况下，在当前步骤的所有可行选择中选择最佳——局部最佳</li>
<li>不可取消：选择一旦作出，进入下一个步骤后，之前的选择不可取消</li>
</ul>
<h3 id="单源最短路—Dijkstra算法"><a href="#单源最短路—Dijkstra算法" class="headerlink" title="单源最短路—Dijkstra算法"></a>单源最短路—Dijkstra算法</h3><p><a href="https://mp.weixin.qq.com/s/gjjrsj95X4w7QdWBlAKnaA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gjjrsj95X4w7QdWBlAKnaA</a></p>
<p><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/</a></p>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C++ program for Dijkstra's single source shortest path algorithm. </span></span><br><span class="line"><span class="comment">// The program is for adjacency matrix representation of the graph </span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; </span></span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// Number of vertices in the graph </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 9 </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// A utility function to find the vertex with minimum distance value, from </span></span><br><span class="line"><span class="comment">// the set of vertices not yet included in shortest path tree </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">int</span> dist[], <span class="keyword">bool</span> sptSet[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// Initialize min value </span></span><br><span class="line">   <span class="keyword">int</span> min = INT_MAX, min_index; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) </span><br><span class="line">     <span class="keyword">if</span> (sptSet[v] == <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) </span><br><span class="line">         min = dist[v], min_index = v; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> min_index; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="comment">// A utility function to print the constructed distance array </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printSolution</span><span class="params">(<span class="keyword">int</span> dist[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Vertex   Distance from Source\n"</span>); </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d tt %d\n"</span>, i, dist[i]); </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="comment">// Function that implements Dijkstra's single source shortest path algorithm </span></span><br><span class="line"><span class="comment">// for a graph represented using adjacency matrix representation </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> graph[V][V], <span class="keyword">int</span> src)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">int</span> dist[V];     <span class="comment">// The output array.  dist[i] will hold the shortest </span></span><br><span class="line">                      <span class="comment">// distance from src to i </span></span><br><span class="line">   </span><br><span class="line">     <span class="keyword">bool</span> sptSet[V]; <span class="comment">// sptSet[i] will be true if vertex i is included in shortest </span></span><br><span class="line">                     <span class="comment">// path tree or shortest distance from src to i is finalized </span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Initialize all distances as INFINITE and stpSet[] as false </span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        dist[i] = INT_MAX, sptSet[i] = <span class="literal">false</span>; </span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Distance of source vertex from itself is always 0 </span></span><br><span class="line">     dist[src] = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Find shortest path for all vertices </span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; V<span class="number">-1</span>; count++) </span><br><span class="line">     &#123; </span><br><span class="line">       <span class="comment">// Pick the minimum distance vertex from the set of vertices not </span></span><br><span class="line">       <span class="comment">// yet processed. u is always equal to src in the first iteration. </span></span><br><span class="line">       <span class="keyword">int</span> u = minDistance(dist, sptSet); </span><br><span class="line">   </span><br><span class="line">       <span class="comment">// Mark the picked vertex as processed </span></span><br><span class="line">       sptSet[u] = <span class="literal">true</span>; </span><br><span class="line">   </span><br><span class="line">       <span class="comment">// Update dist value of the adjacent vertices of the picked vertex. </span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) </span><br><span class="line">   </span><br><span class="line">         <span class="comment">// Update dist[v] only if is not in sptSet, there is an edge from  </span></span><br><span class="line">         <span class="comment">// u to v, and total weight of path from src to  v through u is  </span></span><br><span class="line">         <span class="comment">// smaller than current value of dist[v] </span></span><br><span class="line">         <span class="keyword">if</span> (!sptSet[v] &amp;&amp; graph[u][v] &amp;&amp; dist[u] != INT_MAX  </span><br><span class="line">                                       &amp;&amp; dist[u]+graph[u][v] &lt; dist[v]) </span><br><span class="line">            dist[v] = dist[u] + graph[u][v]; </span><br><span class="line">     &#125; </span><br><span class="line">   </span><br><span class="line">     <span class="comment">// print the constructed distance array </span></span><br><span class="line">     printSolution(dist, V); </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="comment">// driver program to test above function </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">/* Let us create the example graph discussed above */</span></span><br><span class="line">   <span class="keyword">int</span> graph[V][V] = &#123;&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">8</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>&#125;, </span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>&#125; </span><br><span class="line">                     &#125;; </span><br><span class="line">   </span><br><span class="line">    dijkstra(graph, <span class="number">0</span>); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a href="https://mp.weixin.qq.com/s/8bTMRprI_SOCLm_zOTjnKw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8bTMRprI_SOCLm_zOTjnKw</a></p>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><ul>
<li>加点法</li>
<li>稠密图</li>
</ul>
<p><strong>课本P246</strong></p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><ul>
<li>加边法</li>
<li>稀疏图</li>
<li>必须检查加入一条边后是否成环</li>
</ul>
<p><strong>课本P252</strong></p>
<h3 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h3><ul>
<li>从性价比高的物品开始选择</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h2 id="第十二章-超越算法能力的极限"><a href="#第十二章-超越算法能力的极限" class="headerlink" title="第十二章 超越算法能力的极限"></a>第十二章 超越算法能力的极限</h2><h3 id="回溯法-DFS思想"><a href="#回溯法-DFS思想" class="headerlink" title="回溯法(DFS思想)"></a>回溯法(DFS思想)</h3><p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html </a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 针对N叉树的递归回溯法代码模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BackTrace</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;n)</span><br><span class="line">				Output(x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = f (n, t); i &lt;= g (n, t); i++ ) &#123;</span><br><span class="line"> 						x[t] = h(i);</span><br><span class="line">						<span class="keyword">if</span>(Constraint(t) &amp;&amp; Bound (t))</span><br><span class="line">								BackTrace(t+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><p><a href="https://mp.weixin.qq.com/s/AxGaKZQZ8HjlZaF4ifQRTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AxGaKZQZ8HjlZaF4ifQRTQ</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> curRow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//放当前行的皇后时，只需要检查跟前面那些行的皇后有没有冲突</span></span><br><span class="line">    <span class="comment">//不需要考虑后几行，因为后几行的皇后还没放上去呢</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> preRow = <span class="number">0</span>; preRow != curRow; preRow++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[curRow] == c[preRow] ||</span><br><span class="line">           curRow - c[curRow] == preRow - c[preRow] ||</span><br><span class="line">           curRow + c[curRow] == preRow + c[preRow]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">        <span class="comment">// 从0到n-1行，全部都已经放上皇后了，所以答案+1</span></span><br><span class="line">        total++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印出n个皇后具体放在0~n-1行的第几列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col != n; col++) &#123;</span><br><span class="line">            c[row] = col;</span><br><span class="line">            <span class="keyword">if</span>(check(row)) &#123;</span><br><span class="line">                queen(row + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h4><p>书本P328</p>
<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><p>和回溯法的关系</p>
<p><a href="https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search" target="_blank" rel="noopener">https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search</a></p>
<h3 id="分支界限法-BFS思想-最佳边界函数"><a href="#分支界限法-BFS思想-最佳边界函数" class="headerlink" title="分支界限法(BFS思想 + 最佳边界函数)"></a>分支界限法(BFS思想 + 最佳边界函数)</h3><h4 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><p>$lb=\lceil s / 2\rceil$</p>
<p>不失一般性：</p>
<ul>
<li>只考虑以a为起点</li>
<li>只考虑b在c之前的旅程</li>
</ul>
<h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><p><a href="https://www.jianshu.com/p/372dc2571784" target="_blank" rel="noopener">https://www.jianshu.com/p/372dc2571784</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2853119-7dc08762a91519ed.png" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2853119-5105f2ee46526806.png" alt></p>
<h3 id="回溯法与分支界限法的异同"><a href="#回溯法与分支界限法的异同" class="headerlink" title="回溯法与分支界限法的异同"></a>回溯法与分支界限法的异同</h3><p><a href="https://www.jianshu.com/p/c738c8262087" target="_blank" rel="noopener">https://www.jianshu.com/p/c738c8262087</a></p>
<p><strong>回溯法</strong></p>
<ul>
<li>（求解目标）回溯法的求解目标是找出解空间中满足约束条件的一个解或所有解。</li>
<li>（搜索方式深度优先）回溯法会搜索整个解空间，当不满条件时，丢弃，继续搜索下一个儿子结点，如果所有儿子结点都不满足，向上回溯到它的父节点。</li>
</ul>
<p><strong>分支界限法</strong></p>
<ul>
<li>（求解目标）分支限界法的目标一般是在满足约束条件的解中找出在某种意义下的最优解，也有找出满足约束条件的一个解。 </li>
<li>（搜索方式）分支限界法以广度优先或以最小损耗优先的方式搜索解空间。</li>
<li>常见的两种分支界限法<ul>
<li>队列式（FIFO）分支界限法（广度优先）：按照队列先进先出原则选取下一个结点为扩展结点 </li>
<li>优先队列式分支限界法（最小损耗优先）：按照优先队列规定的优先级选取优先级最高的结点成为当前扩展结点</li>
</ul>
</li>
</ul>
<p>以下为瞎J儿押题</p>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ul>
<li>算法：一系列解决问题的明确指令</li>
<li>算法的特点：输入项、输出项、确定性、有限性、可行性</li>
<li>评价算法优劣的标准：时间复杂度、空间复杂度</li>
<li>蛮力法有什么特点：简单、直接、运用范围广、适用于小规模问题</li>
<li>二分搜索的条件：必须采用顺序存储结构、必须按关键字大小有序</li>
<li>分治算法可以解决哪些问题：合并排序、二分、快排</li>
<li>背包问题可以用哪些算法解决？蛮力法、DP、回溯法、贪心、分支界限</li>
<li><p>两种最重要的基本数据结构：数组、链表</p>
</li>
<li><p>能使用递归的算法？分治法、DP</p>
</li>
<li>DP有什么要求？最优化原理、无后效性</li>
<li>矩阵链乘法复杂度？</li>
</ul>
<h2 id="画图题"><a href="#画图题" class="headerlink" title="画图题"></a>画图题</h2><p>回溯法，分支界限法求单源最短路</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(N*logN)$</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(N*logN)$</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(N*logN)$</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n + k)$</td>
<td>/</td>
</tr>
</tbody>
</table>
<p><code></code></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/算法/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2019/06/13/期末Web答辩后的思索/" rel="prev" title="期末Web项目答辩后的思索">
      <i class="fa fa-chevron-left"></i> 期末Web项目答辩后的思索
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2019/06/20/数据库实验复习/" rel="next" title="数据库实验复习">
      数据库实验复习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-绪论"><span class="nav-text">第一章 绪论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-算法效率分析"><span class="nav-text">第二章 算法效率分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#渐进符号—时间复杂度-空间复杂度"><span class="nav-text">渐进符号—时间复杂度/空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求递归的时间-空间复杂度"><span class="nav-text">求递归的时间/空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代换"><span class="nav-text">代换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归树"><span class="nav-text">递归树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主定理"><span class="nav-text">主定理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-蛮力法"><span class="nav-text">第三章 蛮力法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS"><span class="nav-text">BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-减治法"><span class="nav-text">第四章 减治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑排序"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#找大于L小于R的所有数字的范围"><span class="nav-text">找大于L小于R的所有数字的范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-分治法"><span class="nav-text">第五章 分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合并排序"><span class="nav-text">合并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#挖坑法"><span class="nav-text">挖坑法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针交换法-书上方法"><span class="nav-text">指针交换法 (书上方法)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-变治法"><span class="nav-text">第六章 变治法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL树"><span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二三树"><span class="nav-text">二三树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#性质"><span class="nav-text">性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-时空权衡"><span class="nav-text">第七章 时空权衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计数排序"><span class="nav-text">计数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-动态规划"><span class="nav-text">第八章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划性质-amp-amp-适用范围？"><span class="nav-text">动态规划性质&amp;&amp;适用范围？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划典型例题"><span class="nav-text">动态规划典型例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包"><span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子序列-LCS"><span class="nav-text">最长公共子序列(LCS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd求完全最短路径"><span class="nav-text">Floyd求完全最短路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和分治法的异同？"><span class="nav-text">和分治法的异同？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-贪婪技术"><span class="nav-text">第九章 贪婪技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三个条件"><span class="nav-text">三个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单源最短路—Dijkstra算法"><span class="nav-text">单源最短路—Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim算法"><span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal算法"><span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分背包问题"><span class="nav-text">部分背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈夫曼编码"><span class="nav-text">哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十二章-超越算法能力的极限"><span class="nav-text">第十二章 超越算法能力的极限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法-DFS思想"><span class="nav-text">回溯法(DFS思想)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#N皇后"><span class="nav-text">N皇后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈密顿回路"><span class="nav-text">哈密顿回路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS-1"><span class="nav-text">DFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支界限法-BFS思想-最佳边界函数"><span class="nav-text">分支界限法(BFS思想 + 最佳边界函数)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#旅行商问题"><span class="nav-text">旅行商问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单源最短路"><span class="nav-text">单源最短路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法与分支界限法的异同"><span class="nav-text">回溯法与分支界限法的异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#填空题"><span class="nav-text">填空题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#画图题"><span class="nav-text">画图题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法"><span class="nav-text">排序算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hytonight云息</p>
  <div class="site-description" itemprop="description">云之息，浴乎沂，风乎舞雩，咏而归</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HytonightYX" title="GitHub → https://github.com/HytonightYX" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:whosiyuan@qq.com" title="E-Mail → mailto:whosiyuan@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div><a href="http://www.beian.miit.gov.cn">浙ICP备19011570号-2</a></div>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hytonight云息</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/muse.js"></script>
<script src="/blog/js/next-boot.js"></script>



  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : false,
      appId      : 'poBG3RLh2xdaKYTvOB9yLgTP-gzGzoHsz',
      appKey     : 'uKHvvpz0NYgD3n5uxJKWUdVE',
      placeholder: "Lorem Ipsum...",
      avatar     : 'mp',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
